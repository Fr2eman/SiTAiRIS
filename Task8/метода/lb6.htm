<!-- (C) 2004-06 Nick G Shchetko, Anatoly A Matveev for Military Faculty, BSUIR -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//RU">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
<META HTTP-EQUIV="Content-Language" CONTENT="ru">
<title>Лабораторная работа №6</title>
<base target="_top">
</HEAD><BODY>
<div align="center">
  <p><strong>Лабораторная работа № 6</strong></p>
</div>
<div align="center">
		<p><b>«Разработка эффективного ко-да. Функциональ-ное тестирование приложений Java. »</b></p>
</div>
<p><b>1. Цель работы: </b></p>
<p>Изучить методологии функционального тестирования приложений Java.</p>
<p><b>2. Методические указания</b></p>
<p>Пусть есть класс, реализующий несколько
математических функций:</p>
<img src= "6_1.png" ><br />
<p><b>Замечание</b></p>
<p>Иногда требуется снабжать программу модульными тестами.
</p>
<p>Тесты неудобно хранить в самой программе:</p>
<ol>
<li> Усложняет чтение кода.
<li> Такие тесты сложно запускать.
<li> Тесты не относятся к бизнес-логике приложения и должны быть исключены из конечного продукта.
</ol>
<p>Внешняя библиотека, подключенная к проекту, может существенно облегчить разработку и поддержание модульных тестов. Наиболее популярная библиотека для Java – JUnit.

</p>
<p><b>Вариант модульного тестирования без библиотеки</b></p>
<p>Некоторые проверки можно поместить в сам класс.
Доработаем класс CustomMath</p>
<img src= "6_2.png" ><br />
<p><b>Установка JUnit</b></p>
JUnit может быть использован для любого Java-приложения.
Сайт проекта www.junit.org.
Библиотека входит в состав большинства интегрированных сред разработки, в том числе NetBeans.
<p><b>Создание тестового модуля</b></p>
<p>Создание тестового модуля по шаблону может быть произведено с помощью мастера.
Тесты JUnit будут располагаться в ветке Test Packages проекта. Структура папок в Test Packages в общем случае дублирует папки классов Source Packages. Выберите в меню File->New File->… в разделе JUnit пункт Тест для существующего класса («Test for Existing Class»).
</p>
<img src= "6_3.png" ><br />
<img src= "6_4.png" ><br />
<p>В данном случае будут созданы тесты для класса CustomMath.
Настройки оставим по умолчанию: доступ к методам Public, наполнение методов по умолчанию, комментарии Javadoc.
Javadoc - форма организации комментариев в коде с использованием ключевых слов, по которым NetBeans определяет существенную информацию. Если класс оформлен с использованием Javadoc – по нему может быть автоматически создана документация, а также работать контекстная подсказка NetBeans (к примеру, показывать назначение функции).
</p>
<p>Созданный по умолчанию код класса тестов:</p>
<img src= "6_5.png" ><br />
<img src= "6_6.png" ><br />
<p>В коде тестов можно видеть аннотации: информация о назначении методов с символом @ (@BeforeClass, @AfterClass, @Test).
Аннотация @Test отмечает методы, автоматически запускаемые средой тестирования.
@BeforeClass и @AfterClass содержат действия, которые необходимо выполнить до запуска тестов класса (например, подключение к базе данных, или подготовку данных для
обработки) или после выполнения тестов (например, отключение от базы данных, восстановление исходного ее состояния).
</p>
<p><b>Запуск созданных по умолчанию тестов</b></p>
<p>Запуск тестов выполняется через контекстное меню тестируемого класса, пунктом Test File.
</p>
<img src= "6_7.png" ><br />
<p>Вкладка Test Results отображает выводимые на консоль сообщения ( в данном случае размещенные нами в функции main проверки), а также результаты проверки методов тестируемого класса (3 неудачи).
</p>
<img src= "6_8.png" ><br />
<p>Иерархия классов JUnit:</p>
<ul>
<li>java.lang.Object
	<ul>
		<li> org.junit.Assert
		<li> org.junit.Assume
		<li> java.lang.Throwable (implements java.io.Serializable)
			<ul>
		 		<li>java.lang.Error
		 		<ul>
		 		<li>java.lang.AssertionError
		 		</li>
		 		<li>org.junit.ComparisonFailure
		 		</ul>
		 		<li>org.junit.Test.None
		 </ul>
	</ul>
</ul>
<p>Annotation Type Hierarchy</p>
<ul>
<li>org.junit.Test (implements java.lang.annotation.Annotation)
<li>org.junit.Ignore (implements java.lang.annotation.Annotation)
<li>org.junit.BeforeClass (implements java.lang.annotation.Annotation)
<li>org.junit.Before (implements java.lang.annotation.Annotation)
<li>org.junit.AfterClass (implements java.lang.annotation.Annotation)
<li>org.junit.After (implements java.lang.annotation.Annotation)
</ul>
<p>Для проверки правильности выполнений метода в JUnit предусмотрена группа методов Assert, проверяющие условия и в случае несовпадения отмечающие тест не пройденным.
</p>
<p>Функция fail() принудительно отмечает тест не пройденным. Используется, если мы реализуем некую проверку самостоятельно и она не отлавливается функцией assert.
</p>
<p><b>Игнорирование теста</b></p>
<p>В некоторых ситуациях может понадобиться отключить некоторые тесты. Например, возможно в текущей версии используемой вами библиотеки имеется ошибка, или по какой-то причине определенный тест не может быть выполнен в текущей среде. D В JUnit 3.8.x, чтобы отключить тесты, приходилось их комментировать. В JUnit 4 для этих целей вам нужно просто промаркировать игнорируемый тест с помощью аннотации @Ignore.
</p>
<p>Например</p>
<pre><code>
public class CalculatorTest {
		@Ignore("Not running ")
		@Test
		public void testTheWhatSoEverSpecialFunctionality() {
		}
}</code></pre>
<p>
Текст, который передается в аннотации @Ignore, поясняет причину пропуска теста и может использоваться средой разработки. Указывать текст не обязательно, но очень полезно всегда задавать сообщение для того, чтобы позже не забыть про то, что этот тест отключен. 
</p>
<p><b>Обработка исключений</b></p>
<p>
Исключения могут быть правильным поведением метода при определенных условиях ( например, исключение отсутствия файла в случае, если он не доступен ). Можно обрабатывать исключение в тесте с помощью блока try…catch(), либо передавать его далее с помощью ключевого слова throws в описании метода.
Изменим метод testDivision таким образом, чтобы он проверял корректное поведение при делении на 0. Корректным поведением в данном случае является генерация исключения.
</p>
<img src= "6_9.png" ><br />
<p><b>Параметризованные тесты</b></p>
<p>Для проверки бизнес-логики приложений регулярно приходится создавать тесты, количество которых может существенно колебаться. В предшествующих версиях JUnit это приводило к значительным неудобствам - главным образом из-за того, что изменение групп параметров в тестируемом методе требовало написания отдельного тестового сценария для каждой группы.
В версии JUnit 4 реализована возможность, позволяющая создавать общие тесты, в которые можно направлять различные значения параметров. В результате вы можете создать один тестовый сценарий и выполнить его несколько раз - по одному разу для каждого параметра.
</p>
<p>Создание параметрического теста в JUnit 4 производится в пять шагов:
</p>
<ol>
<li> Создание типового теста без конкретных значений параметров.
<li>  Создание метода static, который возвращает тип Collection и маркирует его аннотацией @Parameter.
<li>  Создание полей класса для параметров, которые требуются для типового метода, описанного на шаге 1.
<li>  Создание конструктора, которые связывает параметры коллекции шага 2 с соответствующими полями класса, описанными на шаге 3.
<li> Указание параметризованного запуска тестов с помощью класса Parametrized.
</ol>

</BODY>
</HTML>